//IV.c
// Source file for I-V curve point extraction
// MAH - 07/2014 - Initial Version

#include "fsm.h"
#include "fifo.h"
#include "dac.h"
#include "IV.h"
#include "adc12.h"
#include "ihm.h"
#include "blrtc.h"

//FATFS stack
#include "stm322xg_eval_sdio_sd.h"
#include "ff.h"
#include "diskio.h"
#include "string.h"
#include "stdio.h"

//FreeRtos
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

//definitions and prototypes for IV task
#define IV_STACK_SIZE		        configMINIMAL_STACK_SIZE + 2048
#define IV_TASK_PRIORITY		( tskIDLE_PRIORITY + 3 )

static void vIVTask( void *pvParameters );


#define IV_CURRENT_RESISTOR         (0.1f)
#define IV_CURRENT_CURVE_STEP       (100)
#define IV_CURRENT_DAC_STEP         ((uint16_t) (IV_CURRENT_RESISTOR*IV_CURRENT_CURVE_STEP))
#define IV_VOLTAGE_DIVIDER_FACTOR   (33.4f)
#define IV_VOLTAGE_SC_TOL           2000//(500)
#define IV_DEFAULT_POINT_DELAY      (5)
#define IV_DELAY_TICK_BASE          ( ( TickType_t ) 5 )
#define IV_EVENT_LIST_SIZE          (10)
#define IV_CURVE_SIZE               (ADC12_TYPICAL_VREF / IV_CURRENT_DAC_STEP)
#define MAX_FATFS_ATTEMPT           10

typedef struct IV_FATFS_TAG
{
  FRESULT res;
  FILINFO fno;
  FIL fil;
  DIR dir;
  FATFS fs32;  
}IV_FATFS_T;

// Event type, parameters can be added after super
typedef struct IV_EVENT_TAG
{
    FSM_Event super;
} IV_EVENT_T;

// Event FIFO type
typedef struct IV_EVENT_LIST_TAG
{
    FIFO_T     super;
    IV_EVENT_T list[IV_EVENT_LIST_SIZE];
} IV_EVENT_LIST_T;
 
// IV Point type
typedef struct IV_POINT_TAG
{
    uint16_t v;
    uint16_t i;
    uint16_t correct_i;
} IV_POINT_T;

// IV Curve type
typedef struct IV_CURVE_TAG
{
    FIFO_T     super;
    IV_POINT_T points[IV_CURVE_SIZE];
} IV_CURVE_T;

typedef struct IV_TRACER_TAG
{
    FSM super;
    IV_EVENT_LIST_T events;
    IV_CURVE_T curve;
    IV_POINT_T last_point;
    TickType_t xPointDelay;
    TickType_t xPointDelayTime;
    xTaskHandle task_handle;
    uint32_t point_delay_ms;
    uint32_t point_delay_counter;
    IV_FATFS_T fatfs;
} IV_TRACER_T;

enum IV_SIGNALS
{ 
    IV_START_NEW_CURVE = FSM_USER_SIGNAL,
    IV_POINT_DELAY_TIMEOUT, 
    IV_SHORT_CIRCUIT,
    IV_NEW_POINT,
    IV_DAC_FULL_SCALE
};

static IV_TRACER_T iv_tracer;

FSM_State IV_HAND_IDLE(IV_TRACER_T *me, FSM_Event *e);
FSM_State IV_HAND_OPER(IV_TRACER_T *me, FSM_Event *e);
int IV_Post_Event(IV_TRACER_T *me, IV_EVENT_T *e);
uint16_t IV_Get_Panel_Voltage(void);
uint16_t IV_Get_Panel_Current(void);
void IV_SetCurrent(uint16_t current_in_ma);
int IV_Curve2File(char * filename, IV_CURVE_T * curve, IV_FATFS_T * fatfs_handle);
void IV_Request_Point(void);
void IV_TaskCreate(void);

void rtc2string(RTC_TimeTypeDef time, char * hold_string);

// Initial state. Just performs the initial transition
FSM_State IV_HAND_IDLE(IV_TRACER_T *me, FSM_Event *e)
{    
    switch (e->signal)
    {
        case FSM_ENTRY_SIGNAL:
            //idle state, lets take some sleep
            vTaskSuspend(me->task_handle);
            return FSM_HANDLED();
            
        case IV_START_NEW_CURVE: // event generated by perfome_curve request
            FIFO_Init(&me->curve.super, &me->curve.points, IV_CURVE_SIZE, sizeof(IV_POINT_T));  
            IV_Request_Point();
            return FSM_TRAN(me,IV_HAND_OPER);
            
         case FSM_EXIT_SIGNAL:
            return FSM_HANDLED();  
    }
    
    return FSM_HANDLED();   
}

// Idle, waiting timeout to get the next IV Curve
FSM_State IV_HAND_OPER(IV_TRACER_T *me, FSM_Event *e)
{
    switch (e->signal)
    {
        case FSM_ENTRY_SIGNAL:
            return FSM_HANDLED();
            
        case IV_NEW_POINT:             
          
            // Gets Panel Measure
            me->last_point.v = IV_Get_Panel_Voltage();
            me->last_point.correct_i = IV_Get_Panel_Current();
            
            // Puts point on curve FIFO
            FIFO_Post(&me->curve.super, &me->last_point);
            
            // Increments current by a step
            me->last_point.i += IV_CURRENT_CURVE_STEP;
            IV_SetCurrent(me->last_point.i);
            
            //Delay for next point
            vTaskDelayUntil(&me->xPointDelayTime, me->xPointDelay);
                             
            IV_Request_Point(); // next point !                             
            
            return FSM_HANDLED(); 
            
        case IV_SHORT_CIRCUIT:
        case IV_DAC_FULL_SCALE:
            // Curve done
            // Set DAC to zero here, to reduce temperature
            me->last_point.i = 0;
            IV_SetCurrent(me->last_point.i);
            if(IV_Curve2File("CURVA.TXT", &me->curve, &me->fatfs) > 0)
            {
              IHM_SetLed(USER_LED1, HIGH);
            }
            else
            {
              IHM_SetLed(USER_LED2, HIGH);
            }
            return FSM_TRAN(me,IV_HAND_IDLE); // lets sleep !
            
        case FSM_EXIT_SIGNAL:
            return FSM_HANDLED();   
    }
    
    // Default: Handled
    return FSM_HANDLED();
}                             
                             
void IV_Request_Point(void)
{
    IV_EVENT_T iv_e;
    
    iv_e.super.signal = IV_NEW_POINT;
    IV_Post_Event(&iv_tracer, &iv_e); 
  
}

// Starts a new IV Curve
void IV_Perform_Curve(void)
{
    IV_EVENT_T iv_e;
    vTaskResume(iv_tracer.task_handle); // wake up the iv_tracer task !
    iv_e.super.signal = IV_START_NEW_CURVE;
    IV_Post_Event(&iv_tracer, &iv_e);  
    
    IHM_SetLed(USER_LED1, LOW);
    IHM_SetLed(USER_LED2, LOW);
}

// Gets the panel voltage
uint16_t IV_Get_Panel_Voltage(void)
{
    IV_EVENT_T iv_e;
    
    uint16_t voltage = (uint16_t) (ADC12_GetOutputBufferSample(ADC12_CH1)*IV_VOLTAGE_DIVIDER_FACTOR);
    
    // If panel voltage drops too much, issues short circuit
    if (voltage <= IV_VOLTAGE_SC_TOL)
    {
        iv_e.super.signal = IV_SHORT_CIRCUIT;
        IV_Post_Event(&iv_tracer, &iv_e);
    }
    
    return (voltage); 
}

// Gets the panel voltage
uint16_t IV_Get_Panel_Current(void)
{    
    return ((uint16_t) (ADC12_GetOutputBufferSample(ADC12_CH2)/IV_CURRENT_RESISTOR)); 
}

// Set the current to draw from panel
void IV_SetCurrent(uint16_t current_in_ma)
{
    IV_EVENT_T iv_e;
    
    uint16_t dac_val = ((uint16_t) (current_in_ma * IV_CURRENT_RESISTOR));
    
    if (DAC_SetDACValInMilivolts(DAC_Channel_1, dac_val) == DAC_VALUE_OUTSIDE_BOUNDARIES)
    {
        iv_e.super.signal = IV_DAC_FULL_SCALE;
        IV_Post_Event(&iv_tracer, &iv_e);
    }
        
}

// Post an event to the IV Event list
int IV_Post_Event(IV_TRACER_T *me, IV_EVENT_T *iv_e)
{       
    FIFO_T* element_list_as_fifo = (FIFO_T *) &me->events;
    
    int result = FIFO_Post(element_list_as_fifo, iv_e);
    
    return result; 
}

// Initialization function
void IV_Init(void) 
{
    // This task will run the iv fsm machine 
    IV_TaskCreate();
    
    // Initializes point delay in ms
    iv_tracer.point_delay_ms = IV_DEFAULT_POINT_DELAY;
    
    // Initializes FIFO
    FIFO_Init(&iv_tracer.events.super, 
              &iv_tracer.events.list ,
              IV_EVENT_LIST_SIZE, 
              sizeof(IV_EVENT_T));
    
    // FSM Constructor
    FSM_Ctor(&iv_tracer.super,IV_HAND_IDLE);
    
    // FSM Init
    FSM_Init(&iv_tracer.super);   
    
}

// Event dispatcher for IV Curve tracer
void IV_Process(void)
{
   IV_EVENT_T evt;
  
   if (FIFO_Get(&iv_tracer.events.super, &evt) == FIFO_NOERROR)
       FSM_Dispatch (&iv_tracer.super, &evt.super);  
}

//Creates the iv_tracer main task, this task is responsible to execute the 
//iv_tracer fsm machine
void IV_TaskCreate(void)
{
  xTaskCreate( vIVTask, "IV", IV_STACK_SIZE, NULL, IV_TASK_PRIORITY, &iv_tracer.task_handle);    
}

// iv_tracer task
static void vIVTask( void *pvParameters )
{  
  //Adjusting delay between two measures
  iv_tracer.xPointDelay = IV_DELAY_TICK_BASE;
  iv_tracer.xPointDelay /= portTICK_PERIOD_MS;
  iv_tracer.xPointDelayTime = xTaskGetTickCount();
  
  for(;;)
  {
    IV_Process(); 
  }
}

//TODO: typedef enum for return values
// fatfs_handle is the object responsible for fat32 interface
int IV_Curve2File(char * filename, IV_CURVE_T * curve, IV_FATFS_T * fatfs_handle)
{
  uint32_t i;
  char header[64];
  char data_string[128];
  UINT BytesWritten;
  unsigned int n_attempt;
  
  //check if the caller is a orc
  if(filename == 0)
  {
    return 0;
  }
  
  //check if the requested curve has enough points
  if(curve->super.elements == 0)
  {
    return 0;
  }
  
  SD_InterruptEnable();
  
  memset(&fatfs_handle->fs32, 0, sizeof(FATFS));
  
  fatfs_handle->res = f_mount(0, &fatfs_handle->fs32);
  
  if(fatfs_handle->res != FR_OK)
  {
    return -1;
  }
  
  fatfs_handle->res = f_close(&fatfs_handle->fil);
  
  n_attempt = MAX_FATFS_ATTEMPT;
  
  do{
    fatfs_handle->res = f_open(&fatfs_handle->fil, filename, FA_CREATE_ALWAYS | FA_WRITE);
    n_attempt -= 1;
  }while(n_attempt > 0 && fatfs_handle->res != FR_OK);
  
  if(n_attempt == 0)
  {
    fatfs_handle->res = f_close(&fatfs_handle->fil);
    return -2;  // very bad, check if the retarded user inserted the sd card
  }
  
  f_lseek(&fatfs_handle->fil, (fatfs_handle->fil.fsize)); // EOF please
  
  rtc2string(BLRTC_GetTime(), header);
  
  fatfs_handle->res = f_write(&fatfs_handle->fil, header, strlen(header), &BytesWritten);
  
  if (fatfs_handle->res != FR_OK)
  {
    return -3;    
  }  
  
  //Log the whole curve even the empty points, improve this!
  for(i = 0; i < IV_CURVE_SIZE; i++)
  {
    sprintf(data_string, "V[%d] = %d; I[%d] = %d;\r\n", i, curve->points[i].v, i, curve->points[i].correct_i);
    fatfs_handle->res = f_write(&fatfs_handle->fil, data_string, strlen(data_string), &BytesWritten);
  }  
  
  fatfs_handle->res = f_close(&fatfs_handle->fil);
  
  return 1;
}

void rtc2string(RTC_TimeTypeDef time, char * hold_string)
{
  if(time.RTC_H12 == RTC_H12_AM)
  {
    sprintf(hold_string, "START LOG - RTC -> %d :: %d :: %d  [AM]\r\n", time.RTC_Hours, time.RTC_Minutes, time.RTC_Seconds);
  }
  else
  {
    sprintf(hold_string, "RTC - %d :: %d :: %d  [PM]\r\n", time.RTC_Hours, time.RTC_Minutes, time.RTC_Seconds);
  }  
}